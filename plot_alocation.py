# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PlotAlocation
                                 A QGIS plugin
 Plot alocation for forest inventory
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-28
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Vinicius Richter and Renato Souza Santos
        email                : vinicius00rich@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QDialogButtonBox
from qgis.core import *
from PyQt5.QtWidgets import QMessageBox
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .plot_alocation_dialog import PlotAlocationDialog
import os.path
import processing
import sys
import os
from osgeo import ogr
import geopandas as gpd
from shapely.geometry import Point
import math
import numpy as np
import traceback
from shapely.geometry import shape, mapping, GeometryCollection


class PlotAlocation:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PlotAlocation_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FPT Plot Alocation')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.select_button_connected = False
        self.select_save_button_connected = False

    def update_ok_button_state(self):
        """Ativa o botão OK se todos os campos obrigatórios estiverem preenchidos."""
        is_shp_selected = bool(self.dlg.shp.currentText())
        is_output_name_filled = bool(self.dlg.output_name.text())
        is_plot_area_filled = self.dlg.plot_area.value() > 0
        is_sample_number_filled = self.dlg.sample_number.value() > 0

        self.dlg.button_box.button(QDialogButtonBox.Ok).setEnabled(
            is_shp_selected and is_output_name_filled and is_plot_area_filled and is_sample_number_filled
        )

    def get_selected_epsg(self):
        """Obter o EPSG selecionado pelo usuário."""
        selected_epsg_text = self.dlg.epsg_selector.currentText()
        epsg_code = selected_epsg_text.split('-')[-1].strip()  # Extrair apenas o código EPSG
        return epsg_code

    ##### FUNÇÕES CRIADAS #####
    def load_vectors(self):
        """Preenche a box com o boundary, excluindo layers de pontos"""
        self.dlg.shp.clear()
        layers_list = [layer for layer in QgsProject.instance().mapLayers().values()]
        vectors_layers_list = []
        for layer in layers_list:
            if layer.type() == QgsMapLayer.VectorLayer and layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                vectors_layers_list.append(layer.name())
        self.dlg.shp.addItems(vectors_layers_list)

        # Preencher a QComboBox epsg_selector com os EPSGs e descrições das zonas
        self.update_epsg_selector()

    def update_epsg_selector(self):
        """Atualiza a QComboBox epsg_selector com base na seleção dos botões de rádio"""
        self.dlg.epsg_selector.clear()

        if self.dlg.radio_button_south.isChecked():
            epsg_codes = [
                "Zone 1S - EPSG:32701", "Zone 2S - EPSG:32702", "Zone 3S - EPSG:32703", "Zone 4S - EPSG:32704",
                "Zone 5S - EPSG:32705", "Zone 6S - EPSG:32706", "Zone 7S - EPSG:32707", "Zone 8S - EPSG:32708",
                "Zone 9S - EPSG:32709", "Zone 10S - EPSG:32710", "Zone 11S - EPSG:32711", "Zone 12S - EPSG:32712",
                "Zone 13S - EPSG:32713", "Zone 14S - EPSG:32714", "Zone 15S - EPSG:32715", "Zone 16S - EPSG:32716",
                "Zone 17S - EPSG:32717", "Zone 18S - EPSG:32718", "Zone 19S - EPSG:32719", "Zone 20S - EPSG:32720",
                "Zone 21S - EPSG:32721", "Zone 22S - EPSG:32722", "Zone 23S - EPSG:32723", "Zone 24S - EPSG:32724",
                "Zone 25S - EPSG:32725", "Zone 26S - EPSG:32726", "Zone 27S - EPSG:32727", "Zone 28S - EPSG:32728",
                "Zone 29S - EPSG:32729", "Zone 30S - EPSG:32730", "Zone 31S - EPSG:32731", "Zone 32S - EPSG:32732",
                "Zone 33S - EPSG:32733", "Zone 34S - EPSG:32734", "Zone 35S - EPSG:32735", "Zone 36S - EPSG:32736",
                "Zone 37S - EPSG:32737", "Zone 38S - EPSG:32738", "Zone 39S - EPSG:32739", "Zone 40S - EPSG:32740",
                "Zone 41S - EPSG:32741", "Zone 42S - EPSG:32742", "Zone 43S - EPSG:32743", "Zone 44S - EPSG:32744",
                "Zone 45S - EPSG:32745", "Zone 46S - EPSG:32746", "Zone 47S - EPSG:32747", "Zone 48S - EPSG:32748",
                "Zone 49S - EPSG:32749", "Zone 50S - EPSG:32750", "Zone 51S - EPSG:32751", "Zone 52S - EPSG:32752",
                "Zone 53S - EPSG:32753", "Zone 54S - EPSG:32754", "Zone 55S - EPSG:32755", "Zone 56S - EPSG:32756",
                "Zone 57S - EPSG:32757", "Zone 58S - EPSG:32758", "Zone 59S - EPSG:32759", "Zone 60S - EPSG:32760"
            ]
        else:
            epsg_codes = [
                "Zone 1N - EPSG:32601", "Zone 2N - EPSG:32602", "Zone 3N - EPSG:32603", "Zone 4N - EPSG:32604",
                "Zone 5N - EPSG:32605", "Zone 6N - EPSG:32606", "Zone 7N - EPSG:32607", "Zone 8N - EPSG:32608",
                "Zone 9N - EPSG:32609", "Zone 10N - EPSG:32610", "Zone 11N - EPSG:32611", "Zone 12N - EPSG:32612",
                "Zone 13N - EPSG:32613", "Zone 14N - EPSG:32614", "Zone 15N - EPSG:32615", "Zone 16N - EPSG:32616",
                "Zone 17N - EPSG:32617", "Zone 18N - EPSG:32618", "Zone 19N - EPSG:32619", "Zone 20N - EPSG:32620",
                "Zone 21N - EPSG:32621", "Zone 22N - EPSG:32622", "Zone 23N - EPSG:32623", "Zone 24N - EPSG:32624",
                "Zone 25N - EPSG:32625", "Zone 26N - EPSG:32626", "Zone 27N - EPSG:32627", "Zone 28N - EPSG:32628",
                "Zone 29N - EPSG:32629", "Zone 30N - EPSG:32630", "Zone 31N - EPSG:32631", "Zone 32N - EPSG:32632",
                "Zone 33N - EPSG:32633", "Zone 34N - EPSG:32634", "Zone 35N - EPSG:32635", "Zone 36N - EPSG:32636",
                "Zone 37N - EPSG:32637", "Zone 38N - EPSG:32638", "Zone 39N - EPSG:32639", "Zone 40N - EPSG:32640",
                "Zone 41N - EPSG:32641", "Zone 42N - EPSG:32642", "Zone 43N - EPSG:32643", "Zone 44N - EPSG:32644",
                "Zone 45N - EPSG:32645", "Zone 46N - EPSG:32646", "Zone 47N - EPSG:32647", "Zone 48N - EPSG:32648",
                "Zone 49N - EPSG:32649", "Zone 50N - EPSG:32650", "Zone 51N - EPSG:32651", "Zone 52N - EPSG:32652",
                "Zone 53N - EPSG:32653", "Zone 54N - EPSG:32654", "Zone 55N - EPSG:32655", "Zone 56N - EPSG:32656",
                "Zone 57N - EPSG:32657", "Zone 58N - EPSG:32658", "Zone 59N - EPSG:32659", "Zone 60N - EPSG:32660"
            ]

        self.dlg.epsg_selector.addItems(epsg_codes)

    def open_vector(self):
        """Caixa de diálogo para carregar vetores locais"""
        selected_layer, _ = QFileDialog.getOpenFileName(caption="Select layer",
                                                        filter="Shapefiles (*.shp)")
        # Se a selected_layer não for vazia
        if selected_layer:
            self.iface.addVectorLayer(selected_layer,
                                      os.path.splitext(os.path.basename(selected_layer))[0], "ogr")
            self.load_vectors()

    def transform_to_layer_crs(self, geometry, source_crs, target_crs):
        """Transformar a geometria para o CRS do layer alvo"""
        try:
            transform_context = QgsProject.instance().transformContext()
            coord_transform = QgsCoordinateTransform(source_crs, target_crs, transform_context)
            transformed_geometry = QgsGeometry(geometry)
            if transformed_geometry.transform(coord_transform) == 0:
                return transformed_geometry
            else:
                QgsMessageLog.logMessage("Falha na transformação de geometria.", 'Your Plugin Name', Qgis.Critical)
                return None
        except Exception as e:
            QgsMessageLog.logMessage(f"Erro na transformação de CRS: {e}", 'Your Plugin Name', Qgis.Critical)
            return None

    def set_input_layer(self):
        """Obter a layer definida no combobox shp"""
        layer = None
        layer_name = self.dlg.shp.currentText()
        for layer_ in QgsProject.instance().mapLayers().values():
            if layer_.name() == layer_name:
                layer = layer_
                break

        if not layer:
            QgsMessageLog.logMessage("Layer not found", 'Your Plugin Name', Qgis.Critical)
            return None

        QgsMessageLog.logMessage(f"Selected Layer CRS: {layer.crs().authid()}", 'Your Plugin Name', Qgis.Info)

        # Obter o EPSG selecionado pelo usuário
        selected_epsg = self.get_selected_epsg()
        dest_crs = QgsCoordinateReferenceSystem(selected_epsg)
        transform_context = QgsProject.instance().transformContext()
        coord_transform = QgsCoordinateTransform(layer.crs(), dest_crs, transform_context)

        # Criar uma nova camada para as geometrias transformadas
        transformed_layer = QgsVectorLayer("Polygon?crs={}".format(dest_crs.authid()), "Transformed Layer", "memory")
        provider = transformed_layer.dataProvider()

        # Transformar as geometrias do layer original e adicionar à nova camada
        transformed_features = []
        for feature in layer.getFeatures():
            transformed_geometry = QgsGeometry(feature.geometry())
            if transformed_geometry.transform(coord_transform) == 0:
                transformed_feature = QgsFeature()
                transformed_feature.setGeometry(transformed_geometry)
                transformed_feature.setAttributes(feature.attributes())
                transformed_features.append(transformed_feature)
            else:
                QgsMessageLog.logMessage(f"Failed to transform feature ID {feature.id()}", 'Your Plugin Name',
                                         Qgis.Warning)

        provider.addFeatures(transformed_features)
        transformed_layer.updateExtents()

        QgsMessageLog.logMessage(f"Layer CRS after transformation: {transformed_layer.crs().authid()}",
                                 'Your Plugin Name', Qgis.Info)

        # Calcular a área total dos polígonos (em metros)
        self.total_area = self.calculate_total_area(transformed_layer)
        QgsMessageLog.logMessage(f"Total Area: {self.total_area}", 'Your Plugin Name', Qgis.Info)

        return transformed_layer


    def calculate_total_area(self, layer):
        """Calcular a área total dos polígonos no layer fornecido"""
        total_area = 0
        for feature in layer.getFeatures():
            area = feature.geometry().area()
            QgsMessageLog.logMessage(f"Feature ID {feature.id()} Area: {area}", 'Your Plugin Name', Qgis.Info)
            total_area += area
        return total_area

    def _check_points_distance(self, point, plot_area, existing_points):
        """Check if the point is at a valid distance from existing points and polygon boundaries."""
        radius = math.sqrt(plot_area / math.pi)
        for existing_point in existing_points:
            distance = point.distance(existing_point)
            if distance < radius * 2:
                return False

        # Check distance between point and each polygon boundary
        for feature in self.shp_layer.getFeatures():
            geom = feature.geometry()
            if geom:
                shapely_geom = shape(mapping(geom))  # Convert QGIS geometry to shapely
                boundary = shapely_geom.boundary  # Get shapely geometry boundary
                distance_to_boundary = point.distance(
                    QgsGeometry.fromWkt(boundary.wkt))  # Convert back to QGIS geometry
                if distance_to_boundary < (self.min_border_distance + radius):
                    return False
        return True

    def _check_point_within_polygons(self, point, layer):
        """Check if a point is within any polygons of the layer."""
        for feature in layer.getFeatures():
            if feature.geometry().contains(point):
                return True
        return False

    """Distribuição randomica"""

    def _generate_random_sample_points(self, shp, total_area, plot_area, max_attempts=3000):
        max_number_of_points = self.sample_number
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        valid_points = []
        attempts = 0
        source_crs = shp.crs()
        target_crs = shp.crs()

        while len(valid_points) < max_number_of_points and attempts < max_attempts:
            try:
                x = np.random.uniform(x_min, x_max)
                y = np.random.uniform(y_min, y_max)
            except OverflowError as e:
                QgsMessageLog.logMessage(f"Erro ao gerar valores x ou y: {e}", 'Your Plugin Name', Qgis.Critical)
                break

            point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
            transformed_point = self.transform_to_layer_crs(point, source_crs, target_crs)

            if transformed_point is not None and self._check_point_within_polygons(transformed_point,
                                                                                   shp) and self._check_points_distance(
                    transformed_point, plot_area, valid_points):
                valid_points.append(transformed_point)

            attempts += 1

        if len(valid_points) < max_number_of_points:
            QMessageBox.warning(self.dlg, "Warning!",
                                "Unable to generate plots with the established criteria. Only the possible plots were generated.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None
    """Distribuição sistematica"""

    def _generate_systematic_sample_points(self, shp, plot_area):
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        grid_spacing = math.sqrt(plot_area)
        x_coords = np.arange(x_min, x_max, grid_spacing)
        y_coords = np.arange(y_min, y_max, grid_spacing)

        valid_points = []

        for x in x_coords:
            for y in y_coords:
                point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                if self._check_point_within_polygons(point, shp) and self._check_points_distance(point, plot_area,
                                                                                                 valid_points):
                    valid_points.append(point)

        if len(valid_points) < self.sample_number:
            QMessageBox.warning(self.dlg, "Aviso",
                                "Não foi possível gerar todas as parcelas com os critérios estabelecidos.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None

    """Implementação da Grade Hexagonal"""

    def _generate_hexagonal_sample_points(self, shp, plot_area):
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        radius = math.sqrt((2 * plot_area) / (3 * math.sqrt(3)))
        x_spacing = radius * 3 / 2
        y_spacing = radius * math.sqrt(3)

        valid_points = []

        y = y_min
        row = 0
        while y <= y_max:
            x = x_min + (row % 2) * radius * 3 / 2
            while x <= x_max:
                point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                if self._check_point_within_polygons(point, shp) and self._check_points_distance(point, plot_area,
                                                                                                 valid_points):
                    valid_points.append(point)
                x += x_spacing
            y += y_spacing
            row += 1

        if len(valid_points) < self.sample_number:
            QMessageBox.warning(self.dlg, "Aviso",
                                "Não foi possível gerar todas as parcelas com os critérios estabelecidos.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None

    """Implementação da Rotação da Grade"""

    def _generate_rotated_sample_points(self, shp, plot_area, angle=30):
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        grid_spacing = math.sqrt(plot_area)
        cos_angle = math.cos(math.radians(angle))
        sin_angle = math.sin(math.radians(angle))

        valid_points = []

        center_x = (x_min + x_max) / 2
        center_y = (y_min + y_max) / 2

        y = y_min
        while y <= y_max:
            x = x_min
            while x <= x_max:
                x_centered = x - center_x
                y_centered = y - center_y
                x_rot = cos_angle * x_centered - sin_angle * y_centered + center_x
                y_rot = sin_angle * x_centered + cos_angle * y_centered + center_y

                point = QgsGeometry.fromPointXY(QgsPointXY(x_rot, y_rot))

                if self._check_point_within_polygons(point, shp) and self._check_points_distance(point, plot_area,
                                                                                                 valid_points):
                    valid_points.append(point)

                x += grid_spacing
            y += grid_spacing

        if len(valid_points) < self.sample_number:
            QMessageBox.warning(self.dlg, "Warning!",
                                "Unable to generate plots with the established criteria. Only the possible plots were generated.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None

    def create_point_layer(self, points, crs):
        point_layer = QgsVectorLayer("Point?crs={}".format(crs.authid()), "Sample Points", "memory")
        pr = point_layer.dataProvider()

        point_layer.startEditing()
        for point in points:
            feature = QgsFeature()
            feature.setGeometry(point)
            pr.addFeature(feature)
        point_layer.commitChanges()
        point_layer.updateExtents()

        return point_layer
    ##### FIM FUNÇÕES CRIADAS #####
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PlotAlocation', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def select_output_file(self):
        """Abre um diálogo para selecionar o caminho do arquivo de saída"""
        file_dialog = QFileDialog()
        output_path, _ = file_dialog.getSaveFileName(
            self.dlg,
            "Select Output File",
            "",
            "Shapefiles (*.shp);;All Files (*)"
        )
        if output_path:
            self.dlg.output_name.setText(output_path)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/plot_alocation/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Plot Alocation FPTools'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FPT Plot Alocation'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        if self.first_start:
            self.first_start = False
            self.dlg = PlotAlocationDialog()
            self.dlg.distribution.addItems(["random", "systematic", "systematic - hexagonal", "systematic - rotated",
                                            "systematic - custom"])

            # Definir o botão de rádio "Sul" como selecionado por padrão
            self.dlg.radio_button_south.setChecked(True)

        self.dlg.show()

        self.load_vectors()

        if not self.select_button_connected:
            self.dlg.select_button.clicked.connect(self.open_vector)
            self.dlg.shp.currentIndexChanged.connect(self.update_ok_button_state)
            self.select_button_connected = True

        if not self.select_save_button_connected:
            self.dlg.select_save_button.clicked.connect(self.select_output_file)
            self.dlg.output_name.textChanged.connect(self.update_ok_button_state)
            self.select_save_button_connected = True

        # Conectar os botões de rádio ao método de atualização do EPSG
        self.dlg.radio_button_south.toggled.connect(self.update_epsg_selector)
        self.dlg.radio_button_north.toggled.connect(self.update_epsg_selector)

        # Conectar sinais de alteração dos campos ao método de atualização do botão OK
        self.dlg.plot_area.valueChanged.connect(self.update_ok_button_state)
        self.dlg.sample_number.valueChanged.connect(self.update_ok_button_state)
        self.dlg.min_border_distance.valueChanged.connect(self.update_ok_button_state)
        self.dlg.epsg_selector.currentIndexChanged.connect(self.update_ok_button_state)

        # Inicializar estado do botão OK
        self.update_ok_button_state()

        result = self.dlg.exec_()
        if result:
            self.shp_layer = self.set_input_layer()
            if not self.shp_layer:
                return  # Exit if no polygon layer is selected
            try:
                self.plot_area = self.dlg.plot_area.value()  # Obtém o valor diretamente do QDoubleSpinBox
                QgsMessageLog.logMessage(f"Plot Area: {self.plot_area}", 'Your Plugin Name', Qgis.Info)
                self.sample_number = self.dlg.sample_number.value()  # Obtém o valor diretamente do QDoubleSpinBox
                QgsMessageLog.logMessage(f"Sample Number: {self.sample_number}", 'Your Plugin Name', Qgis.Info)
                self.min_border_distance = self.dlg.min_border_distance.value()  # Obtém o valor diretamente do QDoubleSpinBox
                QgsMessageLog.logMessage(f"Min Border Distance: {self.min_border_distance}", 'Your Plugin Name',
                                         Qgis.Info)
                self.distribution = self.dlg.distribution.currentText()
                QgsMessageLog.logMessage(f"Distribution: {self.distribution}", 'Your Plugin Name', Qgis.Info)

                # Calcular a área total
                self.total_area = self.calculate_total_area(self.shp_layer)
                QgsMessageLog.logMessage(f"Total Area: {self.total_area}", 'Your Plugin Name', Qgis.Info)

                # Verificar se o número de parcelas excede o tamanho da área total do limite
                if self.sample_number * self.plot_area >= self.total_area:
                    QMessageBox.warning(self.dlg, "Aviso", "The number of plots exceeds the total boundary area.")
                    return  # Keep the dialog open
                if self.distribution == "random":
                    point_layer = self._generate_random_sample_points(self.shp_layer, self.total_area, self.plot_area)
                elif self.distribution == "systematic":
                    point_layer = self._generate_systematic_sample_points(self.shp_layer, self.plot_area)
                elif self.distribution == "systematic - hexagonal":
                    point_layer = self._generate_hexagonal_sample_points(self.shp_layer, self.plot_area)
                elif self.distribution == "systematic - rotated":
                    point_layer = self._generate_rotated_sample_points(self.shp_layer, self.plot_area)
                else:
                    QMessageBox.warning(self.dlg, "Aviso", "Distribuição não suportada.")
                    return  # Keep the dialog open

                if point_layer:
                    output_path = self.dlg.output_name.text()
                    output_dir = os.path.dirname(output_path)
                    if output_path and os.path.isdir(output_dir):
                        options = QgsVectorFileWriter.SaveVectorOptions()
                        options.driverName = "ESRI Shapefile"
                        transform_context = QgsProject.instance().transformContext()
                        error = QgsVectorFileWriter.writeAsVectorFormatV3(
                            point_layer,
                            output_path,
                            QgsCoordinateTransformContext(transform_context),
                            options
                        )
                        if error[0] == QgsVectorFileWriter.NoError:
                            QgsMessageLog.logMessage("Point layer saved successfully.", 'Your Plugin Name', Qgis.Info)
                            # Carregar o shapefile salvo no QGIS
                            layer_name = f"Sample points ({self.distribution})"
                            saved_layer = QgsVectorLayer(output_path, layer_name, "ogr")
                            if saved_layer.isValid():
                                QgsProject.instance().addMapLayer(saved_layer)
                            else:
                                QMessageBox.critical(self.dlg, "Erro", "Failed to load the saved layer.")
                                return  # Keep the dialog open
                        else:
                            QMessageBox.critical(self.dlg, "Erro", f"Error saving point layer: {error[1]}")
                            return  # Keep the dialog open
                    else:
                        QMessageBox.critical(self.dlg, "Erro",
                                             "Output path is not specified or directory does not exist.")
                        return  # Keep the dialog open
                else:
                    QMessageBox.critical(self.dlg, "Erro", "Não foi possível gerar a camada de pontos.")
                    return  # Keep the dialog open

            except Exception as e:
                QgsMessageLog.logMessage(f"Erro ao acessar um campo: {e}", 'Your Plugin Name', Qgis.Critical)
                QgsMessageLog.logMessage(traceback.format_exc(), 'Your Plugin Name', Qgis.Critical)
                QMessageBox.critical(self.dlg, "Erro", f"Erro ao acessar um campo: {e}")
                return  # Keep the dialog open







