# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PlotAlocation
                                 A QGIS plugin
 Plot alocation for forest inventory
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-06-28
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Vinicius Richter and Renato Souza Santos
        email                : vinicius00rich@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.utils import iface
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QDialogButtonBox
from qgis.core import *
from PyQt5.QtWidgets import QMessageBox, QProgressDialog
from .resources import *
from .plot_alocation_dialog import PlotAlocationDialog
import os.path
import processing
import sys
import os
import random
from osgeo import ogr
import geopandas as gpd
from shapely.geometry import shape, mapping, GeometryCollection, Point, Polygon
from shapely.ops import unary_union
from shapely import wkt
import math
import numpy as np
import traceback


class PlotAlocation:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PlotAlocation_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FPT Plot Alocation')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.select_button_connected = False
        self.select_save_button_connected = False
        self.dialog_open = False



    def get_selected_epsg(self):
        """Obter o EPSG selecionado pelo usuário."""
        selected_epsg_text = self.dlg.epsg_selector.currentText()
        epsg_code = selected_epsg_text.split('-')[-1].strip()  # Extrair apenas o código EPSG
        return epsg_code

    ##### FUNÇÕES CRIADAS #####
    def load_vectors(self):
        """Preenche a box com o boundary, excluindo layers de pontos"""
        self.dlg.shp.clear()
        layers_list = [layer for layer in QgsProject.instance().mapLayers().values()]
        vectors_layers_list = []
        for layer in layers_list:
            if layer.type() == QgsMapLayer.VectorLayer and layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                vectors_layers_list.append(layer.name())
        self.dlg.shp.addItems(vectors_layers_list)

        # Preencher a QComboBox epsg_selector com os EPSGs e descrições das zonas
        self.update_epsg_selector()

    def update_epsg_selector(self):
        """Atualiza a QComboBox epsg_selector com base na seleção dos botões de rádio"""
        self.dlg.epsg_selector.clear()

        if self.dlg.radio_button_south.isChecked():
            epsg_codes = [
                "Zone 1S - EPSG:32701", "Zone 2S - EPSG:32702", "Zone 3S - EPSG:32703", "Zone 4S - EPSG:32704",
                "Zone 5S - EPSG:32705", "Zone 6S - EPSG:32706", "Zone 7S - EPSG:32707", "Zone 8S - EPSG:32708",
                "Zone 9S - EPSG:32709", "Zone 10S - EPSG:32710", "Zone 11S - EPSG:32711", "Zone 12S - EPSG:32712",
                "Zone 13S - EPSG:32713", "Zone 14S - EPSG:32714", "Zone 15S - EPSG:32715", "Zone 16S - EPSG:32716",
                "Zone 17S - EPSG:32717", "Zone 18S - EPSG:32718", "Zone 19S - EPSG:32719", "Zone 20S - EPSG:32720",
                "Zone 21S - EPSG:32721", "Zone 22S - EPSG:32722", "Zone 23S - EPSG:32723", "Zone 24S - EPSG:32724",
                "Zone 25S - EPSG:32725", "Zone 26S - EPSG:32726", "Zone 27S - EPSG:32727", "Zone 28S - EPSG:32728",
                "Zone 29S - EPSG:32729", "Zone 30S - EPSG:32730", "Zone 31S - EPSG:32731", "Zone 32S - EPSG:32732",
                "Zone 33S - EPSG:32733", "Zone 34S - EPSG:32734", "Zone 35S - EPSG:32735", "Zone 36S - EPSG:32736",
                "Zone 37S - EPSG:32737", "Zone 38S - EPSG:32738", "Zone 39S - EPSG:32739", "Zone 40S - EPSG:32740",
                "Zone 41S - EPSG:32741", "Zone 42S - EPSG:32742", "Zone 43S - EPSG:32743", "Zone 44S - EPSG:32744",
                "Zone 45S - EPSG:32745", "Zone 46S - EPSG:32746", "Zone 47S - EPSG:32747", "Zone 48S - EPSG:32748",
                "Zone 49S - EPSG:32749", "Zone 50S - EPSG:32750", "Zone 51S - EPSG:32751", "Zone 52S - EPSG:32752",
                "Zone 53S - EPSG:32753", "Zone 54S - EPSG:32754", "Zone 55S - EPSG:32755", "Zone 56S - EPSG:32756",
                "Zone 57S - EPSG:32757", "Zone 58S - EPSG:32758", "Zone 59S - EPSG:32759", "Zone 60S - EPSG:32760"
            ]
        else:
            epsg_codes = [
                "Zone 1N - EPSG:32601", "Zone 2N - EPSG:32602", "Zone 3N - EPSG:32603", "Zone 4N - EPSG:32604",
                "Zone 5N - EPSG:32605", "Zone 6N - EPSG:32606", "Zone 7N - EPSG:32607", "Zone 8N - EPSG:32608",
                "Zone 9N - EPSG:32609", "Zone 10N - EPSG:32610", "Zone 11N - EPSG:32611", "Zone 12N - EPSG:32612",
                "Zone 13N - EPSG:32613", "Zone 14N - EPSG:32614", "Zone 15N - EPSG:32615", "Zone 16N - EPSG:32616",
                "Zone 17N - EPSG:32617", "Zone 18N - EPSG:32618", "Zone 19N - EPSG:32619", "Zone 20N - EPSG:32620",
                "Zone 21N - EPSG:32621", "Zone 22N - EPSG:32622", "Zone 23N - EPSG:32623", "Zone 24N - EPSG:32624",
                "Zone 25N - EPSG:32625", "Zone 26N - EPSG:32626", "Zone 27N - EPSG:32627", "Zone 28N - EPSG:32628",
                "Zone 29N - EPSG:32629", "Zone 30N - EPSG:32630", "Zone 31N - EPSG:32631", "Zone 32N - EPSG:32632",
                "Zone 33N - EPSG:32633", "Zone 34N - EPSG:32634", "Zone 35N - EPSG:32635", "Zone 36N - EPSG:32636",
                "Zone 37N - EPSG:32637", "Zone 38N - EPSG:32638", "Zone 39N - EPSG:32639", "Zone 40N - EPSG:32640",
                "Zone 41N - EPSG:32641", "Zone 42N - EPSG:32642", "Zone 43N - EPSG:32643", "Zone 44N - EPSG:32644",
                "Zone 45N - EPSG:32645", "Zone 46N - EPSG:32646", "Zone 47N - EPSG:32647", "Zone 48N - EPSG:32648",
                "Zone 49N - EPSG:32649", "Zone 50N - EPSG:32650", "Zone 51N - EPSG:32651", "Zone 52N - EPSG:32652",
                "Zone 53N - EPSG:32653", "Zone 54N - EPSG:32654", "Zone 55N - EPSG:32655", "Zone 56N - EPSG:32656",
                "Zone 57N - EPSG:32657", "Zone 58N - EPSG:32658", "Zone 59N - EPSG:32659", "Zone 60N - EPSG:32660"
            ]

        self.dlg.epsg_selector.addItems(epsg_codes)
        # Seleciona por padrão o EPSG 32722 (Zone 22S)
        index = self.dlg.epsg_selector.findText("Zone 22S - EPSG:32722")
        if index != -1:
            self.dlg.epsg_selector.setCurrentIndex(index)

    def open_vector(self):
        """Caixa de diálogo para carregar vetores locais"""
        selected_layer, _ = QFileDialog.getOpenFileName(caption="Select layer",
                                                        filter="Shapefiles (*.shp)")
        # Se a selected_layer não for vazia
        if selected_layer:
            self.iface.addVectorLayer(selected_layer,
                                      os.path.splitext(os.path.basename(selected_layer))[0], "ogr")
            self.load_vectors()

    def transform_to_layer_crs(self, geometry, source_crs, target_crs):
        """Transformar a geometria para o CRS do layer alvo"""
        try:
            transform_context = QgsProject.instance().transformContext()
            coord_transform = QgsCoordinateTransform(source_crs, target_crs, transform_context)
            transformed_geometry = QgsGeometry(geometry)
            if transformed_geometry.transform(coord_transform) == 0:
                return transformed_geometry
            else:
                QgsMessageLog.logMessage("Falha na transformação de geometria.", 'Your Plugin Name', Qgis.Critical)
                return None
        except Exception as e:
            QgsMessageLog.logMessage(f"Erro na transformação de CRS: {e}", 'Your Plugin Name', Qgis.Critical)
            return None

    def set_input_layer(self):
        """Obter a layer definida no combobox shp e verificar se o CRS é conhecido."""
        layer = None
        layer_name = self.dlg.shp.currentText()
        for layer_ in QgsProject.instance().mapLayers().values():
            if layer_.name() == layer_name:
                layer = layer_
                break

        if not layer:
            QgsMessageLog.logMessage("Layer not found", 'Your Plugin Name', Qgis.Critical)
            return None

        # Verificar se o CRS do layer é desconhecido
        if not layer.crs().isValid() or layer.crs().authid() == '':
            QMessageBox.warning(self.iface.mainWindow(), "Unknown CRS",
                                "The selected layer's CRS is unknown. Please set a valid CRS before proceeding.")
            return None

        QgsMessageLog.logMessage(f"Selected Layer CRS: {layer.crs().authid()}", 'Your Plugin Name', Qgis.Info)

        # Obter o EPSG selecionado pelo usuário
        selected_epsg = self.get_selected_epsg()
        dest_crs = QgsCoordinateReferenceSystem(selected_epsg)
        transform_context = QgsProject.instance().transformContext()
        coord_transform = QgsCoordinateTransform(layer.crs(), dest_crs, transform_context)

        # Criar uma nova camada para as geometrias transformadas
        transformed_layer = QgsVectorLayer("Polygon?crs={}".format(dest_crs.authid()), "Transformed Layer", "memory")
        provider = transformed_layer.dataProvider()

        # Transformar as geometrias do layer original e adicionar à nova camada
        transformed_features = []
        for feature in layer.getFeatures():
            transformed_geometry = QgsGeometry(feature.geometry())
            if transformed_geometry.transform(coord_transform) == 0:
                transformed_feature = QgsFeature()
                transformed_feature.setGeometry(transformed_geometry)
                transformed_feature.setAttributes(feature.attributes())
                transformed_features.append(transformed_feature)
            else:
                QgsMessageLog.logMessage(f"Failed to transform feature ID {feature.id()}", 'Your Plugin Name',
                                         Qgis.Warning)

        provider.addFeatures(transformed_features)
        transformed_layer.updateExtents()

        QgsMessageLog.logMessage(f"Layer CRS after transformation: {transformed_layer.crs().authid()}",
                                 'Your Plugin Name', Qgis.Info)

        # Calcular a área total dos polígonos (em metros)
        self.total_area = self.calculate_total_area(transformed_layer)
        QgsMessageLog.logMessage(f"Total Area: {self.total_area}", 'Your Plugin Name', Qgis.Info)

        return transformed_layer

    def calculate_total_area(self, layer):
        """Calcular a área total dos polígonos no layer fornecido"""
        total_area = 0
        for feature in layer.getFeatures():
            area = feature.geometry().area()
            QgsMessageLog.logMessage(f"Feature ID {feature.id()} Area: {area}", 'Your Plugin Name', Qgis.Info)
            total_area += area
        return total_area

    def _check_rectangle(self, point, existing_points, width, height):
        """
        Verifica se um retângulo centrado em 'point' é válido.

        :param point: QgsGeometry centrada no ponto do retângulo.
        :param existing_points: Lista de QgsGeometry dos centros dos retângulos existentes.
        :param width: Largura do retângulo.
        :param height: Altura do retângulo.
        :return: True se o retângulo estiver completamente contido em uma feature, não intersectar nenhum retângulo existente, e estiver a pelo menos self.min_border_distance dos limites dos polígonos. False caso contrário.
        """
        point_ = point.asPoint()

        half_width = width / 2
        half_height = height / 2

        # Define os cantos do retângulo ao redor do ponto central
        rectangle_points = [
            QgsPointXY(point_.x() - half_width, point_.y() - half_height),
            QgsPointXY(point_.x() + half_width, point_.y() - half_height),
            QgsPointXY(point_.x() + half_width, point_.y() + half_height),
            QgsPointXY(point_.x() - half_width, point_.y() + half_height),
            QgsPointXY(point_.x() - half_width, point_.y() - half_height)  # Fecha o polígono
        ]

        # Cria a geometria do retângulo como um polígono
        rectangle_geom = QgsGeometry.fromPolygonXY([rectangle_points])

        # Verifica se o retângulo está completamente dentro de pelo menos uma feature na camada
        for feature in self.shp_layer.getFeatures():
            feature_geom = feature.geometry()

            # Buffer negativo da feature para garantir distância mínima dos limites
            buffered_feature_geom = feature_geom.buffer(-self.min_border_distance, 1)

            contains_all_points = all(
                buffered_feature_geom.contains(QgsGeometry.fromPointXY(pt)) for pt in rectangle_points)

            if contains_all_points:
                # Verifica se o retângulo não intersecta nenhum retângulo dos existing_points
                for existing_point in existing_points:
                    existing_point_ = existing_point.asPoint()
                    existing_rectangle_points = [
                        QgsPointXY(existing_point_.x() - half_width, existing_point_.y() - half_height),
                        QgsPointXY(existing_point_.x() + half_width, existing_point_.y() - half_height),
                        QgsPointXY(existing_point_.x() + half_width, existing_point_.y() + half_height),
                        QgsPointXY(existing_point_.x() - half_width, existing_point_.y() + half_height),
                        QgsPointXY(existing_point_.x() - half_width, existing_point_.y() - half_height)
                        # Fecha o polígono
                    ]
                    existing_rectangle_geom = QgsGeometry.fromPolygonXY([existing_rectangle_points])
                    if rectangle_geom.intersects(existing_rectangle_geom):
                        return False  # Se intersecta com um retângulo existente, é inválido

                return True  # Se está contido em uma feature e não intersecta retângulos existentes, é válido

        return False
    def _check_points_distance(self, point, plot_area, existing_points, buffer_type):
        """Check if the point is at a valid distance from existing points and polygon boundaries."""
        if buffer_type == "round":
            radius = math.sqrt(plot_area / math.pi)
            for existing_point in existing_points:
                distance = point.distance(existing_point)
                if distance < radius * 2:
                    return False
            for feature in self.shp_layer.getFeatures():
                geom = feature.geometry()
                if geom:
                    shapely_geom = shape(mapping(geom))  # Convert QGIS geometry to shapely
                    boundary = shapely_geom.boundary  # Get shapely geometry boundary
                    distance_to_boundary = point.distance(
                        QgsGeometry.fromWkt(boundary.wkt))  # Convert back to QGIS geometry
                    if distance_to_boundary < (self.min_border_distance + radius):
                        return False
        elif buffer_type == "squared":
            # Calculate half the side length of the square
            half_side = math.sqrt(plot_area) / 2
            point_x, point_y = point.asPoint().x(), point.asPoint().y()

            # Define the bounds of the square
            min_x, min_y = point_x - half_side, point_y - half_side
            max_x, max_y = point_x + half_side, point_y + half_side

            for existing_point in existing_points:
                existing_x, existing_y = existing_point.asPoint().x(), existing_point.asPoint().y()
                existing_min_x, existing_min_y = existing_x - half_side, existing_y - half_side
                existing_max_x, existing_max_y = existing_x + half_side, existing_y + half_side

                # Check if the squares overlap
                if not (
                        min_x >= existing_max_x or max_x <= existing_min_x or min_y >= existing_max_y or max_y <= existing_min_y):
                    return False

            # Check distance between point and each polygon boundary
            for feature in self.shp_layer.getFeatures():
                geom = feature.geometry()
                if geom:
                    shapely_geom = shape(mapping(geom))  # Convert QGIS geometry to shapely
                    boundary = shapely_geom.boundary  # Get shapely geometry boundary
                    distance_to_boundary = point.distance(
                        QgsGeometry.fromWkt(boundary.wkt))  # Convert back to QGIS geometry
                    if distance_to_boundary < (self.min_border_distance + half_side):
                        return False
        elif buffer_type == "rectangle":
            rect_width = self.custom_plot_format_x_value
            rect_height = self.custom_plot_format_y_value
            return self._check_rectangle(point, existing_points, rect_width,rect_height)
        return True

    def _check_point_within_polygons(self, point, layer):
        """Check if a point is within any polygons of the layer."""
        for feature in layer.getFeatures():
            if feature.geometry().contains(point):
                return True
        return False

    # =================================================
    """Best alocation"""

    def _generate_systematic_best_sampling_sample_points(self, shp, plot_area):
        if self.sample_number < 1:
            max_number_of_points = math.ceil((self.sample_number * self.total_area) / plot_area)
        else:
            max_number_of_points = self.sample_number
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        grid_spacing = math.sqrt(plot_area)
        x_coords = np.arange(x_min, x_max, grid_spacing)
        y_coords = np.arange(y_min, y_max, grid_spacing)
        valid_points = []

        for x in x_coords:
            for y in y_coords:
                point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                if self._check_point_within_polygons(point, shp) and self._check_points_distance(point, plot_area,
                                                                                                 valid_points,
                                                                                                 self.plot_format):
                    valid_points.append(point)

        # Step to adjust points until we reach max_number_of_points
        while len(valid_points) > max_number_of_points:
            min_dist = float('inf')
            closest_pair = None

            # Find the closest pair of points
            for i in range(len(valid_points)):
                for j in range(i + 1, len(valid_points)):
                    dist = valid_points[i].distance(valid_points[j])
                    if dist < min_dist:
                        if self._check_point_within_same_polygon(valid_points[i], valid_points[j], shp):
                            min_dist = dist
                            closest_pair = (i, j)

            if closest_pair:
                i, j = closest_pair
                point1 = valid_points[i].asPoint()
                point2 = valid_points[j].asPoint()

                # Calculate midpoint
                midpoint = QgsGeometry.fromPointXY(QgsPointXY(
                    (point1.x() + point2.x()) / 2,
                    (point1.y() + point2.y()) / 2
                ))

                # Remove the closest pair
                valid_points.pop(max(i, j))
                valid_points.pop(min(i, j))

                # Add the midpoint
                valid_points.append(midpoint)

        valid_points = self.create_point_layer(valid_points, shp.crs())
        if len(valid_points) < max_number_of_points:
            QMessageBox.warning(self.dlg, "Warning!",
                                "Unable to generate plots with the established criteria. Only the possible plots were generated.")
            return valid_points
        return valid_points

    def _check_point_within_same_polygon(self, point1, point2, shp):
        """ Check if both points are within the same polygon in the shapefile """
        for feature in shp.getFeatures():
            polygon = feature.geometry()
            if polygon.contains(point1) and polygon.contains(point2):
                return True
        return False
    """FIM best alocation"""
    #=================================================
    """Distribuição randomica"""
    def _generate_random_sample_points(self, shp, plot_area, max_attempts=3000):
        if self.sample_number < 1:
            max_number_of_points = math.ceil((self.sample_number * self.total_area) / plot_area)
        else:
            max_number_of_points = self.sample_number

        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        valid_points = []
        attempts = 0
        source_crs = shp.crs()
        target_crs = shp.crs()

        while len(valid_points) < max_number_of_points and attempts < max_attempts:
            try:
                x = np.random.uniform(x_min, x_max)
                y = np.random.uniform(y_min, y_max)
            except OverflowError as e:
                QgsMessageLog.logMessage(f"Erro ao gerar valores x ou y: {e}", 'Your Plugin Name', Qgis.Critical)
                break

            point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
            transformed_point = self.transform_to_layer_crs(point, source_crs, target_crs)
            if transformed_point is not None and self._check_point_within_polygons(transformed_point,
                                                                                   shp) and self._check_points_distance(
                    transformed_point, plot_area, valid_points,self.plot_format):
                valid_points.append(transformed_point)

            attempts += 1

        if len(valid_points) < max_number_of_points:
            QMessageBox.warning(self.dlg, "Warning!",
                                "Unable to generate plots with the established criteria. Only the possible plots were generated.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None
    """FIM distribuição randomica"""
    #=====================================================================================
    """Distribuição sistematica"""
    def _generate_systematic_sample_points(self, shp, plot_area):
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        grid_spacing = math.sqrt(plot_area)
        x_coords = np.arange(x_min, x_max, grid_spacing)
        y_coords = np.arange(y_min, y_max, grid_spacing)

        valid_points = []

        for x in x_coords:
            for y in y_coords:
                point = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                if self._check_point_within_polygons(point, shp) and self._check_points_distance(point, plot_area,
                                                                                                 valid_points,self.plot_format):
                    valid_points.append(point)

        if len(valid_points) < self.sample_number:
            QMessageBox.warning(self.dlg, "Aviso",
                                "Não foi possível gerar todas as parcelas com os critérios estabelecidos.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None
    """FIM Distribuição sistematica"""
    # =====================================================================================
    """Distribuição systematic custom"""

    def _generate_systematic_custom_sample_points(self, shp, plot_area):
        extent = shp.extent()
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()

        if not (np.isfinite(x_min) and np.isfinite(y_min) and np.isfinite(x_max) and np.isfinite(y_max)):
            QgsMessageLog.logMessage("Extensão do layer contém valores infinitos ou NaN.", 'Your Plugin Name',
                                     Qgis.Critical)
            return None

        if x_min >= x_max or y_min >= y_max:
            QgsMessageLog.logMessage("Intervalo de valores de x ou y inválido.", 'Your Plugin Name', Qgis.Critical)
            return None

        x_spacing = self.systematic_custom_x_d
        y_spacing = self.systematic_custom_y_d
        rotation_angle = self.systematic_custom_degree

        # Aumenta a área da grade para garantir cobertura após rotação
        padding_factor = 1.5
        x_min_padded = x_min - (x_max - x_min) * padding_factor
        x_max_padded = x_max + (x_max - x_min) * padding_factor
        y_min_padded = y_min - (y_max - y_min) * padding_factor
        y_max_padded = y_max + (y_max - y_min) * padding_factor

        x_coords = np.arange(x_min_padded, x_max_padded, x_spacing)
        y_coords = np.arange(y_min_padded, y_max_padded, y_spacing)

        valid_points = []

        # Rotate points based on the rotation angle
        rotation_angle_rad = np.deg2rad(rotation_angle)
        cos_angle = np.cos(rotation_angle_rad)
        sin_angle = np.sin(rotation_angle_rad)

        # Calculate the center of the bounding box
        center_x = (x_min + x_max) / 2
        center_y = (y_min + y_max) / 2

        for x in x_coords:
            for y in y_coords:
                # Translate point to origin
                translated_x = x - center_x
                translated_y = y - center_y

                # Apply rotation
                rotated_x = cos_angle * translated_x - sin_angle * translated_y
                rotated_y = sin_angle * translated_x + cos_angle * translated_y

                # Translate point back
                final_x = rotated_x + center_x
                final_y = rotated_y + center_y

                point = QgsGeometry.fromPointXY(QgsPointXY(final_x, final_y))

                if self._check_point_within_polygons(point, shp) and self._check_points_distance(point, plot_area,
                                                                                                 valid_points,
                                                                                                 self.plot_format):
                    valid_points.append(point)

        if len(valid_points) < self.sample_number:
            QMessageBox.warning(self.dlg, "Aviso",
                                "Não foi possível gerar todas as parcelas com os critérios estabelecidos.")

        if valid_points:
            point_layer = self.create_point_layer(valid_points, shp.crs())
            return point_layer
        else:
            QgsMessageLog.logMessage("Não foi possível gerar parcelas com os critérios estabelecidos.",
                                     'Your Plugin Name', Qgis.Critical)
            return None
    """FIM Distribuição systematic custom"""

    # =====================================================================================
    def create_point_layer(self, points, crs):
        point_layer = QgsVectorLayer("Point?crs={}".format(crs.authid()), "Sample Points", "memory")
        pr = point_layer.dataProvider()

        point_layer.startEditing()
        for point in points:
            feature = QgsFeature()
            feature.setGeometry(point)
            pr.addFeature(feature)
        point_layer.commitChanges()
        point_layer.updateExtents()

        return point_layer
    ##### FIM FUNÇÕES CRIADAS #####
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PlotAlocation', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def select_output_file(self):
        """Abre um diálogo para selecionar o caminho do arquivo de saída"""
        file_dialog = QFileDialog()
        output_path, _ = file_dialog.getSaveFileName(
            self.dlg,
            "Select Output File",
            "",
            "Shapefiles (*.shp);;All Files (*)"
        )
        if output_path:
            self.dlg.output_name.setText(output_path)

    def create_buffer_layer(self, point_layer, buffer_distance, buffer_type):
        buffer_layer = QgsVectorLayer("Polygon?crs={}".format(point_layer.crs().authid()), "Buffer Layer", "memory")
        provider = buffer_layer.dataProvider()

        for feature in point_layer.getFeatures():
            geom = feature.geometry()
            if buffer_type == "round":
                buffer_geom = geom.buffer(buffer_distance, 30)  # 30 segments to approximate a circle
            elif buffer_type == "squared":
                # Create a squared buffer
                center = geom.asPoint()
                x, y = center.x(), center.y()
                half_side = buffer_distance / 2
                coords = [
                    QgsPointXY(x - half_side, y - half_side),
                    QgsPointXY(x + half_side, y - half_side),
                    QgsPointXY(x + half_side, y + half_side),
                    QgsPointXY(x - half_side, y + half_side),
                    QgsPointXY(x - half_side, y - half_side)
                ]
                buffer_geom = QgsGeometry.fromPolygonXY([coords])
            elif buffer_type == "rectangle":
                point_ = geom.asPoint()

                half_width = self.custom_plot_format_x_value / 2
                half_height = self.custom_plot_format_y_value / 2

                # Define os cantos do retângulo ao redor do ponto central
                rectangle_points = [
                    QgsPointXY(point_.x() - half_width, point_.y() - half_height),
                    QgsPointXY(point_.x() + half_width, point_.y() - half_height),
                    QgsPointXY(point_.x() + half_width, point_.y() + half_height),
                    QgsPointXY(point_.x() - half_width, point_.y() + half_height)
                ]

                buffer_geom = QgsGeometry.fromPolygonXY([rectangle_points])

            buffer_feature = QgsFeature()
            buffer_feature.setGeometry(buffer_geom)
            provider.addFeatures([buffer_feature])

        buffer_layer.updateExtents()
        self.set_layer_opacity(buffer_layer, 0.5)
        QgsProject.instance().addMapLayer(buffer_layer)

    def set_layer_opacity(self, layer, opacity):
        """Set the layer opacity."""
        renderer = layer.renderer()
        if renderer is not None:
            symbol = renderer.symbol()
            symbol.setOpacity(opacity)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/plot_alocation/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Plot Alocation FPTools'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FPT Plot Alocation'),
                action)
            self.iface.removeToolBarIcon(action)

    def update_ok_button_state(self):
        """Activate the OK button if all required fields are filled."""
        is_shp_selected = bool(self.dlg.shp.currentText())
        plot_format = self.dlg.plot_format_selector.currentText()
        distribution = self.dlg.distribution.currentText()

        if plot_format == "rectangle":
            # Para o formato 'rectangle', é necessário que os valores X e Y sejam preenchidos e diferentes de zero
            is_x_filled = self.dlg.custom_plot_format_x_value.value() > 0
            is_y_filled = self.dlg.custom_plot_format_y_value.value() > 0
            is_valid = is_shp_selected and is_x_filled and is_y_filled
            if distribution == "systematic custom":
                # Para a distribuição 'systematic custom', os valores X e Y devem ser preenchidos e diferentes de zero
                is_x_filled = self.dlg.systematic_custom_x_d.value() > 0
                is_y_filled = self.dlg.systematic_custom_y_d.value() > 0
                # Exigir 'plot_area' se o formato não for 'rectangle'
                is_plot_area_filled = plot_format == "rectangle" or self.dlg.plot_area.value() > 0
                is_valid = is_shp_selected and is_x_filled and is_y_filled and is_plot_area_filled
        elif distribution == "systematic custom":
            # Para a distribuição 'systematic custom', os valores X e Y devem ser preenchidos e diferentes de zero
            is_x_filled = self.dlg.systematic_custom_x_d.value() > 0
            is_y_filled = self.dlg.systematic_custom_y_d.value() > 0
            # Exigir 'plot_area' se o formato não for 'rectangle'
            is_plot_area_filled = plot_format == "rectangle" or self.dlg.plot_area.value() > 0
            is_valid = is_shp_selected and is_x_filled and is_y_filled and is_plot_area_filled
        else:
            # Para outros formatos, o campo 'plot_area' é necessário
            is_plot_area_filled = self.dlg.plot_area.value() > 0
            is_sample_number_filled = self.dlg.sample_number.value() > 0 if self.dlg.sample_number.isEnabled() else True
            is_valid = is_shp_selected and is_plot_area_filled and is_sample_number_filled

        self.dlg.button_box.button(QDialogButtonBox.Ok).setEnabled(is_valid)

    def update_sample_number_state(self):
        """Ativa ou desativa o campo sample_number dependendo da distribuição selecionada."""
        distribution = self.dlg.distribution.currentText()
        if distribution == "systematic" or distribution == "systematic custom":
            self.dlg.sample_number.setEnabled(False)
        else:
            self.dlg.sample_number.setEnabled(True)

    def update_systematic_custom_parameters_state(self):
        """Enable or disable systematic custom parameters based on the distribution type."""
        is_custom_systematic = self.dlg.distribution.currentText() == "systematic custom"
        self.dlg.systematic_custom_x_d.setEnabled(is_custom_systematic)
        self.dlg.systematic_custom_y_d.setEnabled(is_custom_systematic)
        self.dlg.systematic_custom_x_label.setEnabled(is_custom_systematic)
        self.dlg.systematic_custom_y_label.setEnabled(is_custom_systematic)
        self.dlg.systematic_custom_title.setEnabled(is_custom_systematic)
        self.dlg.systematic_custom_degree_label.setEnabled(is_custom_systematic)
        self.dlg.systematic_custom_degree.setEnabled(is_custom_systematic)

    def update_rectangle_plot_format_parameters_state(self):
        is_custom_plot_format = self.dlg.plot_format_selector.currentText() == "rectangle"
        self.dlg.custom_plot_format_label_x.setEnabled(is_custom_plot_format)
        self.dlg.custom_plot_format_label_y.setEnabled(is_custom_plot_format)
        self.dlg.custom_plot_format_x_value.setEnabled(is_custom_plot_format)
        self.dlg.custom_plot_format_y_value.setEnabled(is_custom_plot_format)

        # Desativa o campo 'Plot area' se o formato selecionado é 'rectangle'
        self.dlg.plot_area.setEnabled(not is_custom_plot_format)



    def run(self):
        """Run method that performs all the real work"""
        if self.dialog_open:  # Check if the dialog is already open
            QMessageBox.warning(self.iface.mainWindow(), "Plugin Already Open", "The plugin is already open.")
            return

        if self.first_start:
            self.first_start = False
            self.dlg = PlotAlocationDialog()
            self.dlg.distribution.addItems(["random", "best sampling", "systematic", "systematic custom"])

            # Define o botão de rádio "Sul" como selecionado por padrão
            self.dlg.radio_button_south.setChecked(True)

            # Initialize the plot_format_selector options
            self.dlg.plot_format_selector.addItems(["round", "squared", "rectangle"])

            # Connect the dialog's finished signal to a method that sets dialog_open to False
            self.dlg.finished.connect(self.on_dialog_closed)

        self.dialog_open = True  # Set the attribute to True when opening the dialog
        self.dlg.show()

        self.load_vectors()

        if not self.select_button_connected:
            self.dlg.select_button.clicked.connect(self.open_vector)
            self.dlg.shp.currentIndexChanged.connect(self.update_ok_button_state)
            self.select_button_connected = True

        if not self.select_save_button_connected:
            self.dlg.select_save_button.clicked.connect(self.select_output_file)
            self.dlg.output_name.textChanged.connect(self.update_ok_button_state)
            self.select_save_button_connected = True

        self.dlg.radio_button_south.toggled.connect(self.update_epsg_selector)
        self.dlg.radio_button_north.toggled.connect(self.update_epsg_selector)

        self.dlg.plot_area.valueChanged.connect(self.update_ok_button_state)
        self.dlg.sample_number.valueChanged.connect(self.update_ok_button_state)
        self.dlg.min_border_distance.valueChanged.connect(self.update_ok_button_state)
        self.dlg.epsg_selector.currentIndexChanged.connect(self.update_ok_button_state)

        self.dlg.distribution.currentIndexChanged.connect(self.update_sample_number_state)
        self.dlg.distribution.currentIndexChanged.connect(self.update_systematic_custom_parameters_state)
        self.dlg.plot_format_selector.currentIndexChanged.connect(self.update_systematic_custom_parameters_state)
        self.dlg.distribution.currentIndexChanged.connect(self.update_rectangle_plot_format_parameters_state)
        self.dlg.plot_format_selector.currentIndexChanged.connect(self.update_rectangle_plot_format_parameters_state)
        self.dlg.distribution.currentIndexChanged.connect(self.update_ok_button_state)
        self.dlg.plot_format_selector.currentIndexChanged.connect(self.update_ok_button_state)
        self.dlg.custom_plot_format_x_value.valueChanged.connect(self.update_ok_button_state)
        self.dlg.custom_plot_format_y_value.valueChanged.connect(self.update_ok_button_state)
        self.dlg.custom_plot_format_y_value.valueChanged.connect(self.update_systematic_custom_parameters_state)
        self.dlg.custom_plot_format_x_value.valueChanged.connect(self.update_systematic_custom_parameters_state)
        self.dlg.systematic_custom_x_d.valueChanged.connect(self.update_ok_button_state)
        self.dlg.systematic_custom_y_d.valueChanged.connect(self.update_ok_button_state)

        self.update_ok_button_state()
        self.update_sample_number_state()
        self.update_systematic_custom_parameters_state()

        result = self.dlg.exec_()
        if result:
            self.shp_layer = self.set_input_layer()
            if not self.shp_layer:
                return
            try:
                self.plot_area = self.dlg.plot_area.value()
                if self.dlg.plot_format_selector.currentText() == "rectangle":
                    self.custom_plot_format_x_value = float(
                        self.dlg.custom_plot_format_x_value.value())
                    self.custom_plot_format_y_value = float(
                        self.dlg.custom_plot_format_y_value.value())
                    self.plot_area = self.custom_plot_format_x_value * self.custom_plot_format_y_value

                if self.plot_area <= 0:
                    raise ValueError("Plot area must be greater than zero.")
                QgsMessageLog.logMessage(f"Plot Area: {self.plot_area}", 'Your Plugin Name', Qgis.Info)

                self.sample_number = self.dlg.sample_number.value()
                if self.sample_number < 0:
                    raise ValueError("Sample number must be non-negative.")
                QgsMessageLog.logMessage(f"Sample Number: {self.sample_number}", 'Your Plugin Name', Qgis.Info)

                self.min_border_distance = self.dlg.min_border_distance.value()
                if self.min_border_distance < 0:
                    raise ValueError("Minimum border distance must be non-negative.")
                QgsMessageLog.logMessage(f"Min Border Distance: {self.min_border_distance}", 'Your Plugin Name', Qgis.Info)

                self.distribution = self.dlg.distribution.currentText()
                QgsMessageLog.logMessage(f"Distribution: {self.distribution}", 'Your Plugin Name', Qgis.Info)
                self.buffer_check_box = self.dlg.buffer_check_box.isChecked()
                QgsMessageLog.logMessage(f"Buffer Check Box: {self.buffer_check_box}", 'Your Plugin Name', Qgis.Info)
                self.plot_format = self.dlg.plot_format_selector.currentText()
                QgsMessageLog.logMessage(f"Plot Format: {self.plot_format}", 'Your Plugin Name', Qgis.Info)

                self.total_area = self.calculate_total_area(self.shp_layer)
                if self.total_area <= 0:
                    raise ValueError("Total area must be greater than zero.")
                QgsMessageLog.logMessage(f"Total Area: {self.total_area}", 'Your Plugin Name', Qgis.Info)

                if self.sample_number * self.plot_area >= self.total_area:
                    QMessageBox.warning(self.dlg, "Aviso", "The number of plots exceeds the total boundary area.")
                    return

                point_layer = None
                if self.distribution == "random":
                    point_layer = self._generate_random_sample_points(self.shp_layer, self.plot_area)
                elif self.distribution == "systematic":
                    point_layer = self._generate_systematic_sample_points(self.shp_layer, self.plot_area)
                elif self.distribution == "best sampling":
                    point_layer = self._generate_systematic_best_sampling_sample_points(self.shp_layer, self.plot_area)
                elif self.distribution == "systematic custom":
                    self.systematic_custom_x_d = self.dlg.systematic_custom_x_d.value()
                    self.systematic_custom_y_d = self.dlg.systematic_custom_y_d.value()
                    self.systematic_custom_degree = self.dlg.systematic_custom_degree.value()

                    point_layer = self._generate_systematic_custom_sample_points(self.shp_layer, self.plot_area)
                else:
                    QMessageBox.warning(self.dlg, "Aviso", "Distribuição não suportada.")
                    return

                if point_layer:
                    output_path = self.dlg.output_name.text()
                    if output_path:
                        output_dir = os.path.dirname(output_path)
                        if os.path.isdir(output_dir):
                            options = QgsVectorFileWriter.SaveVectorOptions()
                            options.driverName = "ESRI Shapefile"
                            transform_context = QgsProject.instance().transformContext()
                            error = QgsVectorFileWriter.writeAsVectorFormatV3(
                                point_layer,
                                output_path,
                                QgsCoordinateTransformContext(transform_context),
                                options
                            )
                            if error[0] == QgsVectorFileWriter.NoError:
                                saved_layer = QgsVectorLayer(output_path, layer_name, "ogr")
                                if saved_layer.isValid():
                                    QgsProject.instance().addMapLayer(saved_layer)

                                    if self.buffer_check_box:
                                        buffer_distance = math.sqrt(
                                            self.plot_area / math.pi) if self.plot_format == "round" else math.sqrt(self.plot_area)
                                        self.create_buffer_layer(saved_layer, buffer_distance, self.plot_format)
                                else:
                                    QMessageBox.critical(self.dlg, "Erro", "Failed to load the saved layer.")
                                    return
                            else:
                                QMessageBox.critical(self.dlg, "Erro", f"Error saving point layer: {error[1]}")
                                return
                        else:
                            QMessageBox.critical(self.dlg, "Erro", "Output directory does not exist.")
                            return
                    else:
                        QgsProject.instance().addMapLayer(point_layer)

                        if self.buffer_check_box:
                            buffer_distance = math.sqrt(
                                self.plot_area / math.pi) if self.plot_format == "round" else math.sqrt(self.plot_area)
                            self.create_buffer_layer(point_layer, buffer_distance, self.plot_format)
                else:
                    QMessageBox.critical(self.dlg, "Erro", "Não foi possível gerar a camada de pontos.")
                    return

            except Exception as e:
                QgsMessageLog.logMessage(f"Erro ao acessar um campo: {e}", 'Your Plugin Name', Qgis.Critical)
                QgsMessageLog.logMessage(traceback.format_exc(), 'Your Plugin Name', Qgis.Critical)
                QMessageBox.critical(self.dlg, "Erro", f"Erro ao acessar um campo: {e}")
                return

    def on_dialog_closed(self):
        self.dialog_open = False









